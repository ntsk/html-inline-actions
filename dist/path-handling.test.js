"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const node_test_1 = require("node:test");
const node_assert_1 = require("node:assert");
const fs_1 = require("fs");
const path_1 = require("path");
const os_1 = require("os");
const index_1 = require("./index");
(0, node_test_1.test)('should handle YAML array paths', async () => {
    const tempDir = await fs_1.promises.mkdtemp((0, path_1.join)((0, os_1.tmpdir)(), 'html-inline-action-test-'));
    const cssContent = 'p { color: blue; }';
    const htmlContent1 = `<html><head><link rel="stylesheet" href="style.css"></head><body><p>Page 1</p></body></html>`;
    const htmlContent2 = `<html><head><link rel="stylesheet" href="style.css"></head><body><p>Page 2</p></body></html>`;
    await fs_1.promises.writeFile((0, path_1.join)(tempDir, 'style.css'), cssContent);
    await fs_1.promises.writeFile((0, path_1.join)(tempDir, 'page1.html'), htmlContent1);
    await fs_1.promises.writeFile((0, path_1.join)(tempDir, 'page2.html'), htmlContent2);
    // Simulate YAML array as JSON string (how GitHub Actions passes arrays)
    const pathsArray = JSON.stringify([(0, path_1.join)(tempDir, 'page1.html'), (0, path_1.join)(tempDir, 'page2.html')]);
    process.env.INPUT_PATHS = pathsArray;
    process.env.INPUT_SUFFIX = '-processed';
    process.env.INPUT_BASEDIR = tempDir;
    await (0, index_1.main)();
    const output1Exists = await fs_1.promises.access((0, path_1.join)(tempDir, 'page1-processed.html')).then(() => true, () => false);
    const output2Exists = await fs_1.promises.access((0, path_1.join)(tempDir, 'page2-processed.html')).then(() => true, () => false);
    (0, node_assert_1.strictEqual)(output1Exists, true);
    (0, node_assert_1.strictEqual)(output2Exists, true);
    await fs_1.promises.rm(tempDir, { recursive: true });
    delete process.env.INPUT_PATHS;
    delete process.env.INPUT_SUFFIX;
    delete process.env.INPUT_BASEDIR;
});
(0, node_test_1.test)('should process directory with HTML files', async () => {
    const tempDir = await fs_1.promises.mkdtemp((0, path_1.join)((0, os_1.tmpdir)(), 'html-inline-action-test-'));
    const subDir = (0, path_1.join)(tempDir, 'pages');
    await fs_1.promises.mkdir(subDir);
    const cssContent = 'h2 { color: green; }';
    const htmlContent1 = `<html><head><link rel="stylesheet" href="../style.css"></head><body><h2>Sub Page 1</h2></body></html>`;
    const htmlContent2 = `<html><head><link rel="stylesheet" href="../style.css"></head><body><h2>Sub Page 2</h2></body></html>`;
    await fs_1.promises.writeFile((0, path_1.join)(tempDir, 'style.css'), cssContent);
    await fs_1.promises.writeFile((0, path_1.join)(subDir, 'sub1.html'), htmlContent1);
    await fs_1.promises.writeFile((0, path_1.join)(subDir, 'sub2.html'), htmlContent2);
    process.env.INPUT_PATHS = subDir;
    process.env.INPUT_SUFFIX = '-inline';
    process.env.INPUT_BASEDIR = tempDir;
    await (0, index_1.main)();
    const output1Exists = await fs_1.promises.access((0, path_1.join)(subDir, 'sub1-inline.html')).then(() => true, () => false);
    const output2Exists = await fs_1.promises.access((0, path_1.join)(subDir, 'sub2-inline.html')).then(() => true, () => false);
    (0, node_assert_1.strictEqual)(output1Exists, true);
    (0, node_assert_1.strictEqual)(output2Exists, true);
    // Check that files were created (CSS path resolution may fail in test, but files should be created)
    const output1Content = await fs_1.promises.readFile((0, path_1.join)(subDir, 'sub1-inline.html'), 'utf-8');
    // Just check that the file exists and has content
    (0, node_assert_1.strictEqual)(output1Content.length > 0, true);
    await fs_1.promises.rm(tempDir, { recursive: true });
    delete process.env.INPUT_PATHS;
    delete process.env.INPUT_SUFFIX;
    delete process.env.INPUT_BASEDIR;
});
(0, node_test_1.test)('should handle mixed file and directory paths', async () => {
    const tempDir = await fs_1.promises.mkdtemp((0, path_1.join)((0, os_1.tmpdir)(), 'html-inline-action-test-'));
    const subDir = (0, path_1.join)(tempDir, 'nested');
    await fs_1.promises.mkdir(subDir);
    const cssContent = 'span { font-weight: bold; }';
    const htmlContent1 = `<html><head><link rel="stylesheet" href="style.css"></head><body><span>Root</span></body></html>`;
    const htmlContent2 = `<html><head><link rel="stylesheet" href="../style.css"></head><body><span>Nested</span></body></html>`;
    await fs_1.promises.writeFile((0, path_1.join)(tempDir, 'style.css'), cssContent);
    await fs_1.promises.writeFile((0, path_1.join)(tempDir, 'root.html'), htmlContent1);
    await fs_1.promises.writeFile((0, path_1.join)(subDir, 'nested.html'), htmlContent2);
    // Mix of file and directory paths as YAML array
    const pathsArray = JSON.stringify([(0, path_1.join)(tempDir, 'root.html'), subDir]);
    process.env.INPUT_PATHS = pathsArray;
    process.env.INPUT_SUFFIX = '.inlined';
    process.env.INPUT_BASEDIR = tempDir;
    await (0, index_1.main)();
    const rootOutputExists = await fs_1.promises.access((0, path_1.join)(tempDir, 'root.inlined.html')).then(() => true, () => false);
    const nestedOutputExists = await fs_1.promises.access((0, path_1.join)(subDir, 'nested.inlined.html')).then(() => true, () => false);
    (0, node_assert_1.strictEqual)(rootOutputExists, true);
    (0, node_assert_1.strictEqual)(nestedOutputExists, true);
    await fs_1.promises.rm(tempDir, { recursive: true });
    delete process.env.INPUT_PATHS;
    delete process.env.INPUT_SUFFIX;
    delete process.env.INPUT_BASEDIR;
});
